---
title: "Atelier 4: Mod√®les lin√©aires"
subtitle: "S√©rie d'ateliers R du CSBQ"
author: "Centre de la Science de la Biodiversit√© du Qu√©bec"
output:
  xaringan::moon_reader:
    includes:
      in_header: qcbsR-header.html
    lib_dir: assets
    seal: true
    css: ["default", "qcbsR.css", "qcbsR-fonts.css"]
    nature:
      beforeInit: "qcbsR-macros.js"

---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  comment = "#",
  collapse = TRUE,
  #cache = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width=6, fig.height=6,
  fig.retina = 3,
  fig.align = 'center'
)
options(repos=structure(c(CRAN="http://cran.r-project.org")))
```

class: inverse, center, middle

```{r install_pkgs, message=FALSE, warning=FALSE, include=FALSE, results=0}
# Standard procedure to check and install packages and their dependencies, if needed.

list.of.packages <- c('dplyr', 'vegan', 'e1071', 'MASS', 'car','effect', 'car')

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]

if(length(new.packages) > 0) {
  install.packages(new.packages, dependencies = TRUE) 
  print(paste0("The following package was installed:", new.packages)) 
} else if(length(new.packages) == 0) {
    print("All packages were already installed previously")
  }
```

# ¿ propos de cet atelier
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=repo&message=dev&color=6f42c1&logo=github)](https://github.com/QCBSRworkshops/workshop04)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=wiki&message=04&logo=wikipedia)](https://wiki.qcbs.ca/r_atelier4)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=Diapos&message=04&color=red&logo=html5)](https://qcbsrworkshops.github.io/workshop04/workshop04-fr/workshop04-fr.html)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=Diapos&message=04&color=red&logo=adobe-acrobat-reader)](https://qcbsrworkshops.github.io/workshop04/workshop04-fr/workshop04-fr.pdf)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=script&message=04&color=2a50b8&logo=r)](https://qcbsrworkshops.github.io/workshop04/workshop04-fr/workshop04-fr.R)

---

# Packages requis

* [dplyr](https://cran.r-project.org/package=dplyr)
* [vegan](https://cran.r-project.org/package=vegan)
* [e1071](https://cran.r-project.org/package=e1071)
* [MASS](https://cran.r-project.org/package=MASS)
* [car](https://cran.r-project.org/package=car)
* [effect](https://cran.r-project.org/package=effect)

<br>

```R
install.packages(c('dplyr', 'vegan', 'e1071', 'MASS', 'car', 'effect'))
```

---

# Objectifs d'apprentissage

.large[-Apprendre la structure d'un mod√®le lin√©aire et ses *diff√©rentes variantes*.]
<br>
<br>
<br>
--

.center[
![:scale 80%](images/schema.png)
]

???

Note au pr√©sentateur: Ce sh√©ma repr√©sente les diff√©rentes variantes d'un mod√®le lin√©aire qui sera pr√©sent√©es durant l'atelier. 


---
# Objectifs d'apprentissage

.large[-Apprendre la structure d'un mod√®le lin√©aire et ses diff√©rentes variantes.]
<br>
<br>
.large[-Apprendre comment faire un mod√®le lin√©aire dans R avec `lm()` et `anova()`]
<br>
<br>
.large[-Apprendre comment identifier un mod√®le dont les conditions d'application ne sont pas rencontr√©es et comment r√®gler le probl√®me.] 

---

# Qu'est-ce qu'un mod√®le lin√©aire ?

#### Un **mod√®le lin√©aire** ...

... d√©crit la relation entre une variable (la **r√©ponse**) et une ou plusieurs autres variables (les **pr√©dicteurs**).

... est utilis√© pour analyser une **hypoth√®se bien formul√©e**, souvent associ√©e √† une question de recherche plus g√©n√©rale.

... est utilis√© pour faire des inf√©rences sur la **direction** et la **force** d'une relation, et notre **confiance** dans les estimations de l'effet.


???

- Point important : Il y a beaucoup de travail scientifique √† faire avant de formuler un mod√®le lin√©aire.
- Il est recommand√© de formuler clairement les attentes concernant la direction et la force d'une relation en tant que pr√©dictions avant d'effectuer un mod√®le lin√©aire.


---

# Exemple : Abondance et masse des esp√®ces d'oiseaux

#### Hypoth√®se

> Pour diff√©rentes esp√®ces d'oiseaux, la masse moyenne d'un individu a un effet sur l'abondance maximale de l'esp√®ce, en raison de contraintes √©cologiques (sources de nourriture, disponibilit√© de l'habitat, etc.).

#### Pr√©diction
> Les esp√®ces caract√©ris√©es par des individus plus grands ont une abondance maximale plus faible.

--

.center[

**Discussion en groupe**

*Quelle variable est la r√©ponse ? Quelle est le pr√©dicteur ?*
  
*Quelles sont nos attentes concernant la direction et la force de la relation ?*
]

???

- Court : Oiseaux plus grands -> moins de nourriture et d'espace
- R√©ponse : Abondance maximale
- Pr√©dicteur : Poids moyen (d'un individu)
- Direction : Inverse ou "n√©gative" (une masse plus √©lev√© entra√Æne une abondance plus faible)
- La force : Aucune attente !

---

# Exemple : Abondance et masse des esp√®ces d'oiseaux

#### Regardons les donn√©es ...

Importer le jeu de donn√©es "birdsdiet" :

```{r, eval=TRUE, echo=FALSE}
bird <- read.csv("data/birdsdiet.csv", stringsAsFactors = TRUE)
```

```{r, eval = FALSE}
bird <- read.csv("birdsdiet.csv", stringsAsFactors = TRUE)
```

Visualiser le tableau de la structure des donn√©es en utilisant la fonction `str()` :

```{r}
str(bird)
```

???

- Il suffit pour l'instant d'expliquer les variables d'int√©r√™t (vous trouverez plus d'informations sur l'ensemble des donn√©es dans le wiki : <https://wiki.qcbs.ca/r_atelier4#effectuer_un_modele_lineaire>)
- "MaxAbund" : La plus grande abondance observ√©e sur un site en Am√©rique du Nord (continu / num√©rique)
- "Masse" : La taille du corps moyenne en grammes (continue / num√©rique)

---

# Exemple : Abondance et masse des esp√®ces d'oiseaux

#### Regardons les donn√©es ...



.pull-left[
Mesures communes de **localisation** (tendance centrale) :

<br>

- Moyenne **arithm√©tique** $\bar{x} = \frac{1}{n} \sum_{i=1}^{n} x_{i}$
```{r}
mean(bird$MaxAbund)
```
<br>
- **M√©diane** (valeur s√©parant la moiti√© sup√©rieure de la moiti√© inf√©rieure d'un √©chantillon)
```{r}
median(bird$MaxAbund)
```
]

.pull-right[

Mesure communes de **variation** (dispersion) :

<br>

- **Variance** $\sigma^2 = \frac{1}{n} \sum_{i=1}^{n} {(x_{i} - \bar{x})}^2$
```{r}
var(bird$MaxAbund)
```
<br>
- **√âcart type** $\sigma$ 
```{r}
sd(bird$MaxAbund)
```
]

???

- Cette diapositive n'a pour but que de rappeler des concepts de base. 
- Les participant.e.s qui ont des difficult√©s avec ces mesures peuvent avoir des difficult√©s de comprendre les autres concepts pr√©sent√©s dans l'atelier.
- Oui, il existe d'autres types de moyens dont nous n'avons g√©n√©ralement pas besoin pour les mod√®les lin√©aires : moyenne g√©om√©trique, harmonique, ...
- La d√©finition de la m√©diane est omise car elle peut √™tre source de confusion pour certains participant.e.s : $\mathrm {median} (x)={\frac {1}{2}}(x_{\lfloor (n+1)/2\rfloor }+x_{\lceil (n+1)/2\rceil })$

---

# Exemple : Abondance et masse des esp√®ces d'oiseaux

Tracer la r√©ponse en fonction du pr√©dicteur:

```{r}
plot(bird$Mass, bird$MaxAbund)
```

???
- Assurer que les participants comprennent comment le graphique est li√© √† l'hypoth√®se !

---

# Exemple : Abondance et masse des esp√®ces d'oiseaux

Comment trouver la "meilleure" estimation de la relation ?

```{r, eval=FALSE}
plot(bird$Mass, bird$MaxAbund)
```

```{r, echo=FALSE}
plot(bird$Mass, bird$MaxAbund)
abline(coef = c(70, -.03),  lwd = 1.5, lty = 2, col = palette()[2])
abline(coef = c(20, -.005), lwd = 1.5, lty = 2, col = palette()[4])
abline(coef = c(200, -.1),  lwd = 1.5, lty = 2, col = palette()[6])
```


???
- La question est destin√©e √† rester sans r√©ponse pour l'instant.
- La "meilleure" estimation est la ligne qui minimise la somme des carr√©s, ce qui devrait devenir clair √† travers les prochaines diapositives
- La "meilleure" estimation peut √©galement dire : Il n'y a pas de relation (similaire √† la ligne bleue dans le graphique).

---

# Formulation d'un mod√®le lin√©aire

#### Variables

- $y_i$ est une observation de la **r√©ponse** $y$  
  (par exemple, l'abondance maximale des esp√®ces $i$)

- $x_i$ est une observation correspondante du **pr√©dicteur** $x$  
  (par exemple, le poids moyen d'un individu d'une esp√®ce $i$)

#### Relation suppos√©e

$$ y_i = \beta_0 + \beta_1 \times x_i + \epsilon_i$$


- Le param√®tre $\beta_0$ est **l'ordonn√©e √† l'origine** (ou constante)
- Le param√®tre $\beta_1$ quantifie **l'effet** de $x$ sur $y$.
- Le r√©sidu $\epsilon_i$ repr√©sent la variation **non expliqu√©e**
- La **valeur pr√©dite** de $y_i$ se d√©finit comme : $\hat{y}_i = \beta_0 + \beta_1 \times x_i$


???

- Prener du temps avec cette diapositive, toutes les d√©finitions sont importantes.
- Comprendre les param√®tres : important pour savoir ce qui sera estim√© et interpr√©t√© ult√©rieurement
- Comprendre les r√©sidus et les valeurs ajust√©es : Important pour la v√©rification des mod√®les par la suite
- En th√©orie, les participants devraient savoir tout cela gr√¢ce √† leurs cours de statistiques ; en pratique, la connaissance des d√©finitions est parfois faible


---

# Conditions d'application du mod√®le lin√©aire


$$y_i = \beta_0 + \beta_1 \times x_i + \epsilon_i$$

#### Distribution normale

Les **r√©sidus** $\epsilon$ suivent une **distribution normale** avec une moyenne de $0$ et une variance de $\sigma^2$
$$\epsilon_i \sim \mathcal{N}(0,\,\sigma^2)$$

```{r, echo=FALSE, fig.height=4, fig.width=6}
x <- seq(-5, 5, length=100)
p <- dnorm(x, 0, 1)
plot(x, p, type = "l", lty = 2, lwd = 1.5,  xlab = "Residuals", ylab = "Probability", xaxt = "n")
```

---

# Conditions d'application du mod√®le lin√©aire


$$y_i = \beta_0 + \beta_1 \times x_i + \epsilon_i$$

#### Distribution normale

Les **r√©sidus** $\epsilon$ suivent une **distribution normale** avec une moyenne de $0$ et une variance de $\sigma^2$
$$\epsilon_i \sim \mathcal{N}(0,\,\sigma^2)$$

**Cela veut dire :** Chaque obsevation $y_i$ suit une distribution normale,  
avec moyenne $\hat{y} = \beta_0 + \beta_1 \times x_i$ et variance $\sigma^2$: 

$$y_i \sim \mathcal{N}(\hat{y},\,\sigma^2)$$

.alert[**Cela ne veut pas dire**] que l'ensemble des valeurs observ√©es $y$ ~~doit suivre une distribution normale~~.

???

- L'id√©e fausse selon laquelle $y$ plut√¥t que $\epsilon$ doit suivre une distribution normale est tr√®s courante.


---

# Conditions d'application du mod√®le lin√©aire

$$y_i = \beta_0 + \beta_1 \times x_i + \epsilon_i$$
$$\epsilon_i \sim \mathcal{N}(0,\,\sigma^2)$$


#### Homosc√©dasticit√©
- Tous les r√©sidus $\epsilon$ suivent la m√™me distribution, la **variance** $\sigma^2$ **reste constante**.

<br>
<br>

#### Ind√©pendance des r√©sidus
- Chaque r√©sidu $\epsilon_i$ est **ind√©pendant** de tout autre r√©sidu. 


---

# Conditions d'application du mod√®le lin√©aire

$$y_i = \beta_0 + \beta_1 \times x_i + \epsilon_i$$
$$\epsilon_i \sim \mathcal{N}(0,\,\sigma^2)$$

#### R√©sum√© des conditions d'application
- Relation lin√©aire entre la r√©ponse et le pr√©dicteur
- Les r√©sidus suivent une distribution normale avec une moyenne de $0$
- Les r√©sidus sont distribu√©s de mani√®re identique (*homosc√©dasticit√©*)
- Les r√©sidus sont ind√©pendants les uns des autres


???

- La d√©finition compl√®te d'un mod√®le lin√©aire se compose toujours des deux √©quations pr√©sent√©es


---

# Notation des mod√®les lin√©aires

#### Notation math√©matique (pour des manuscrits)

- Observations individuelles :  
  $y_i = \beta_0 + \beta_1 \times x_i + \epsilon_i \quad \textrm{with} \quad \epsilon_i \sim \mathcal{N}(0,\,\sigma^2)$

<br>

- Toutes les observations (notation matricielle, interception incluse dans $\mathbf{X}$ et $\boldsymbol{\beta}$) :   
  $\mathbf{y}= \mathbf{X}\boldsymbol{\beta} + \mathbf{\epsilon} \quad \textrm{with} \quad \epsilon_i \sim \mathcal{N}(0,\,I_n\sigma^2)$  

<br>

#### Notation en R

.pull-left[
- Formule du mod√®le :  
  ```{r, eval=FALSE}
  y ~ 1 + x
  ```  
]

.pull-right[
- Ou encore plus simple : 
  ```{r, eval=FALSE}
  y ~ x
  ```  
  (inclut aussi la constante)
]
  
.alert[Il ne faut jamais m√©langer les diff√©rentes types de notation !]


???

- Cette diapositive est destin√©e √†aider les participant.e.s √† comprendre les diff√©rents types de description qu'on peut rencontrer
- Il n'est pas du tout n√©cessaire d'entrer dans le d√©tail de la notation matricielle.
- La notation R n'est pas ad√©quate pour pr√©parer une publication.

---

# Effectuer une mod√®le lin√©aire

$$y_i = \beta_0 + \beta_1 \times x_i + \epsilon_i$$
$$\epsilon_i \sim \mathcal{N}(0,\,\sigma^2)$$

#### Estimation du mod√®le

- Trouver les "meilleures" estimations des param√®tres $\beta_0,\, \beta_1$.
- Les "meilleurs" param√®tres sont ceux qui minimisent la somme des r√©sidus au carr√© $\sum{\epsilon_i^2}$
- Cette m√©thode est appel√©e la m√©thode de **moindres carr√©s ordinaire** (MCO)


---

# Mod√®les lin√©aires

.center[
![:scale 100%](images/schema.png)
]


---

class: inverse, center, middle

# R√©gression lin√©aire avec R

---

# R√©gression lin√©aire avec R

Revenons sur les oiseaux ...

```{r}
plot(bird$Mass, bird$MaxAbund)
```

---

# R√©gression lin√©aire avec R

#### Formulation du mod√®le

> *Hypoth√®se*: Pour diff√©rentes esp√®ces d'oiseaux, la **masse moyenne d'un individu a un effet sur l'abondance maximale** de l'esp√®ce, en raison de contraintes √©cologiques (sources de nourriture, disponibilit√© de l'habitat, etc.).


--

**√âquation du mod√®le**

$\textrm{MaxAbund}_i = \beta_0 + \beta_1 \times \textrm{Mass}_i + \epsilon_i \;, \quad \epsilon_i \sim \mathcal{N}(0, \sigma^2)$

<br>

--

**Formule du mod√®le en R**

```{r, eval=FALSE}
MaxAbund ~ Mass
```

???
- La formulation du mod√®le peut √™tre pos√©e comme question aux participant.e.s


---

# R√©gression lin√©aire avec R

.center[.small[
**√âtape 1**   
Formuler et ex√©cuter un mod√®le lin√©aire bas√© sur un hypoth√®se

**√âtape 2**  
V√©rifier les conditions d'application du mod√®le lin√©aire
]]

<br>

.pull-left[.center[![:faic](arrow-down)]] .pull-right[.center[![:faic](arrow-down)]]

.pull-left[.center[*Conditions sont satisfaits ?*]

.small[.center[**√âtape 3**  ]
- Analyser les param√®tres de r√©gression
- Tracer le mod√®le
- Effectuer des tests de signification sur les estimations des param√®tres (si n√©cessaire)
]]

.pull-right[.center[*Conditions non satisfaites ?*]

.center[Envisager l'utilisation d'un *Mod√®le lin√©aire g√©n√©ralis√©* (GLM) ou la transformation des donn√©es]

.pull-left[.center[![:faic](arrow-down)]] .pull-right[.center[![:faic](arrow-down)]]

.small[
.pull-left[
Utiliser un GLM mieux adapt√© aux donn√©es
]

.pull-right[
Retourner √† l'√âtape 1 avec des variables transform√©es
]]]

---

# R√©gression lin√©aire avec R

#### **√âtape 1.** Formuler et ex√©cuter un mod√®le lin√©aire

La fonction `lm()` est utilis√©e pour ajuster un mod√®le lin√©aire, en fournissant la formule du mod√®le comme premier argument ::


```{r eval=TRUE}
lm1 <- lm(MaxAbund ~ Mass, data = bird)
```

- `lm1` : Nouvel objet contenant le mod√®le lin√©aire
- `MaxAbund ~ Mass` : Formule du mod√®le 
- `bird` : objet contenant les variables


---

# R√©gression lin√©aire avec R

#### **√âtape 1.** Formuler et ex√©cuter un mod√®le lin√©aire

Examinons les estimations des param√®tres :

```{r, eval=TRUE}
lm1
```

.center[
*Comment les param√®tres se comparent-ils √† nos pr√©dictions ?*
]

--

.center[
**Peut-on se fier aux estimations du mod√®le ?**
]


???
- Les questions peuvent √™tre utilis√©es pour une discussion en groupe
- La pr√©diction √©tait : *Les esp√®ces caract√©ris√©es par des individus plus grands ont une abondance maximale plus faible.*
- Le param√®tre pour la "masse" *ne correspond pas √† notre pr√©diction* car il est positif !
- Nous ne savons pas si nous pouvons nous fier aux estimations - pour cela, nous avons besoin de l'√©tape 2

---

# R√©gression lin√©aire avec R

#### **√âtape 2.** V√©rifier les conditions d'application avec les graphiques diagnostics

Nous pouvons produire **quatre graphiques diagnostics** d'un objet `lm` :

```{r, eval=FALSE, fig.height=6, fig.width=8}
par(mfrow=c(2,2))
plot(lm1)
```

- `par()` : Fonction pour d√©finir les param√®tres du graphique
- `mfrow=c(2,2)`:  Param√®tre graphique permettant d'afficher une grille de 2 x 2 graphiques √† la fois
- `plot()`: Fonction pour produire les graphiques

???

- Comment faire pour ne montrer qu'une seule parcelle √† la fois : `par(mfrow=1)`.

---

# R√©gression lin√©aire avec R

#### **√âtape 2.** V√©rifier les conditions d'application avec les graphiques diagnostics

```{r, eval=FALSE}
par(mfrow=c(2,2)
plot(lm1)
```

```{r, echo=FALSE, fig.height=4.75, fig.width=5.5}
par(mfrow=c(2,2), mar = c(4,4,2,1.1), oma =c(0,0,0,0))
plot(lm1)
```

.center[**Comment interpr√©ter ces graphiques ?**]

---

# Graph. #1 - R√©sidus vs valeurs pr√©dites

**Ce qu'on voit :**  
* Axe des **Y** : Residus $\epsilon_i$
* Axe des **X** : Valeurs pr√©dites $\hat{y_i} = \beta_0 + \beta_1 \times x_i$

<span style="color:green">**Ce qu'on esp√®re voir :**</span> Dispersion de points sans patron


**Motivation :** Indication si les r√©sidus sont *ind√©pendants* et *uniform√©ment distribu√©s*.

```{r, echo = FALSE, fig.height=5, fig.width=6.5}
  set.seed(1234564)
  x <- rnorm(100,10,10)
  y <- 2*x+0 + rnorm(100)
  lm <- lm(y~x)
  plot(lm, which = 1)
```

???

- La dispersion sans patron est parfois d√©crite comme "des √©toiles dans le firmament".

---
# Graphique # 1 - R√©sidus vs valeurs pr√©dites

.alert[Ce qui devrait nous rendre m√©fiants :]

```{r, echo=FALSE, fig.height=4.5, fig.width=8.5, warning=FALSE}
par(mfrow=c(1,2))
set.seed(1234564)
x = rnorm(100,10,10)
y = (x)^2 + rnorm(length(x),0,30)
lm=lm(y~scale(x))
plot(lm,which = 1, main = "Non-lin√©aire", col.main="red")

x = abs(rnorm(100,10,10))
y = (x) + rnorm(length(x), 0, x)
lm=lm(y~scale(x))
plot(lm,which = 1, main = "H√©t√©rosc√©dastique", col.main="red")
```

**Quoi faire ?**

- Utiliser plut√¥t un **mod√®le lin√©aire g√©n√©ralis√©** (MLG) qui permet d'autres distributions : Poisson, binomial, binomial n√©gatif, etc.)
- Essayer de **transformer** la r√©ponse et/ou pr√©dicteurs

???

- Expliquez que "h√©t√©rosc√©dastique" est l'oppos√© de "homosc√©dastique", ce qui signifie que la condition de normalit√© est non-respect√©e.

---

# Graphique # 2 - √âchelle localis√©
**Ce qu'on voit :**  
* Axe des **Y** : Racine carr√©e des r√©sidus standardis√©s $\sqrt{\frac{\epsilon_i}{\sigma}}$
* Axe des **X** : Valeurs pr√©dites $\hat{y_i} = \beta_0 + \beta_1 \times x_i$

<span style="color:green">**Ce qu'on esp√®re voir :**</span> Dispersion de points sans patron

**Motivation :** Parfois plus facile de d√©tecter si les conditions d'application ne sont pas respect√©es, surtout quand le pr√©dicteur est distribu√© de mani√®re in√©gale.

```{r, echo=FALSE, fig.height=4.5, fig.width=6, warning=FALSE}
set.seed(1234564)
x <- 1:100
y <- x + rnorm(100,sd=5)
lm=lm(y~x)
plot(lm,which = 3)
```

---

# Graphique # 2 - √âchelle localis√©

.alert[Ce qui devrait nous rendre m√©fiants :]

```{r, echo=FALSE, fig.height=4.5, fig.width=6, warning=FALSE}
set.seed(2)
x = abs(rnorm(100,10,10))
y = (x) + rnorm(length(x), 0, x)
lm=lm(y~scale(x))
plot(lm,which = 3)
```

.center[*Forte tendance dans les r√©sidus*]

???

- Quoi fair ? Voire graphique #1

---

# Graphique # 3 - Normal QQ

**Ce qu'on voit :**  
* **Y**-axis: Residus standardis√©s $\frac{\epsilon_i}{\sigma}$
* **X**-axis: Distribution normale standard $\mathcal{N}(0, \sigma^2)$

<span style="color:green">**Ce qu'on esp√®re voir :**</span> Points sur la ligne 1:1

**Motivation :** Comparer la distribution (quantiles) des r√©sidus √† une distribution normale standard

```{r, echo=FALSE, fig.height=4.5, fig.width=6, warning=FALSE}
set.seed(1234564)
x <- 1:100
y <- x + rnorm(100,sd=5)
lm=lm(y~x)
plot(lm, which = 2)

```

---

# Graphique # 3 - Normal QQ

.alert[Ce qui devrait nous rendre m√©fiants :]

```{r, echo=FALSE, fig.height=4.5, fig.width=6, warning=FALSE}
set.seed(2)
x = abs(rnorm(100,10,10))
y = (x) + rnorm(length(x), 0, x)
lm=lm(y~scale(x))
plot(lm, which = 2)
```

.center[*Les r√©sidus ne suivent pas une distribution normale*]


---

# Graphique # 4 - R√©sidus vs effet de levier

**Motivation :**

- Le mod√®le ne devrait **pas d√©pendre fortement d'observations isol√©es**.
- Les **points de levier** sont des observations extr√™mes du pr√©dicteur. 
- Le **mod√®le passe pr√®s des points de levier**, car ils manquent d'observations voisines.
- Les points de levier **<span style="color:red">peuvent</span> (ou <span style="color:green">pas</span>) avoir une grande influence sur la r√©gression**
- L'influence peut √™tre quantifi√©e par **la distance Cook : plus de 0,5 est probl√©matique**.

---

# Examples: Effet levier et influence

```{r, echo=FALSE, fig.height=8, fig.width=7.7, warning=FALSE}
par(mfrow=c(3, 1), mar = c(4, 15, 1, 3), cex = 1.2)
set.seed(1234564)
x <- 1:20
y <- rnorm(x, x, 2)
lm0 <- lm(y ~ x)
# plot 1
plot(x, y, ylim = c(-4, 22), xlab = '', ylab = ''); abline(lm0, col = 2); points(11, -3, pch = 15)
# add 20, 10 point to the new lm
xx <- c(x, 11); yy <- c(y, -3)
abline(lm(yy ~ xx), col = 2, lty = 3)
text(-20, 10, srt=0, adj = 0, labels = "* Pas d'effet de levier \n* Faible influence
", xpd = TRUE, cex = 1.5)
# plot 2
plot(x, y, ylim = c(-4, 32), xlim = c(0, 31), xlab = '', ylab = ''); abline(lm0, col = 2); points(30, 30, pch = 15)
# add 20, 10 point to the new lm
xx <- c(x, 30); yy <- c(y, 30)
abline(lm(yy ~ xx), col = 2, lty = 3)
text(-33, 15, srt=0, adj = 0, labels = "* Effet de levier \n* Pas d'influence", xpd = TRUE, cex = 1.5)

# plot 3
plot(x, y, ylim = c(-4, 32), xlim = c(0, 31), xlab = '', ylab = ''); abline(lm0, col = 2); points(30, 15, pch = 15)
# add 20, 10 point to the new lm
xx <- c(x, 30); yy <- c(y, 15)
abline(lm(yy ~ xx), col = 2, lty = 3)
text(-33, 15, srt=0, adj = 0, labels = '* Effet de levier \n* Influence √©lev√©e', xpd = TRUE, cex = 1.5)
```


???

- Tous les graphiques ont la r√©ponse sur l'axe des y et le pr√©dicteur sur l'axe des x
- Pour √©viter la confusion : Il ne s'agit pas de graphiques diagnostics sue cette diapositive !

---

# Graphique # 4 - R√©sidus vs effet de levier

**Ce qu'on voit :**  
* Axe des **Y** : Residus standardis√©s $\frac{\epsilon_i}{\sigma}$
* Axe des **X** : Effet de levier
* Ligne rouge en tirets : distance Cook de 0.5

<span style="color:green">**Ce qu'on esp√®re voir :**</span> Pas de points de levier avec influence elev√©e

```{r, echo=FALSE, fig.height=4.5, fig.width=9, warning=FALSE}
par(mfrow=c(1,2))
set.seed(1234564)
x <- 1:100
y <- x + rnorm(100,sd=5)
lm=lm(y~x)
plot(lm, which = 5, main = "Aucune observation influente", col.main=palette()[3])

set.seed(1234564)
x = abs(rnorm(100,10,10))
y = (x) + rnorm(length(x), 0, x)
lm=lm(y~scale(x))
plot(lm, which = 5, main = "Effet de levier et faible influence",  col.main=palette()[3])
```

---

# Graphique # 4 - R√©sidus vs effet de levier

.alert[Ce qui devrait nous rendre m√©fiants :]

<br />

```{r, echo=FALSE, fig.height=5, fig.width=8, warning=FALSE}
set.seed(1234564)
x = abs(rnorm(100,10,10))
y = (x) + rnorm(length(x), 0, x)
y[29] <- 100
lm=lm(y~scale(x))
plot(lm, which = 5, main = "Effet de levier et influence √©lev√©e")
```

<br>

.alert[Il ne faut jamais supprimer les valeurs aberrantes sans avoir des bonnes raisons de le faire]

???

- Point 29 a un effet de levier √©lev√© et une distance Cook > 0,5
- Raison potentielle pour supprimer les valeurs aberrantes : Erreur de mesure √©vidente

---

# **√âtape 2**. V√©rifier les conditions d'application pour `lm1`

```{r, eval=FALSE, fig.height=5.5, fig.width=7.5}
par(mfrow=c(2,2))
plot(lm1)
```

```{r, echo=FALSE, fig.height=5.5, fig.width=7.5}
par(mfrow=c(2,2), mar = c(4,4,2,1.1), oma =c(0,0,0,0))
plot(lm1)
```

**Discussion :** Le mod√®le `lm1` respecte-t-il les conditions du mod√®le lin√©aire ?

???

- Graphiques 1 et 2 : pr√©sence de fortes tendances
- Graphique 3 : les r√©sidus ne suivent pas une distribution normale
- Graphique 4 : point 32 a un effet de levier important et une influence (tr√®s √©lev√©)


---

# Conditions non-respect√©es - Quelle est la cause ?

Tra√ßons le mod√®le avec les observations ...

```{r, fig.height=4, fig.width=11}
par(mfrow = c(1,2))
coef(lm1) # constante et pente
plot(MaxAbund ~ Mass, data=bird) # graphique √† gauche
abline(lm1) # ligne d√©finie par les param√®tres du mod√®le
hist(residuals(lm1)) # graphique √† droite : distribution des r√©sidus
```

---

# Conditions non-respect√©es - Quelle est la cause ?

On peut verifier si les r√©sidus suivent une distribution normale √† l'aide d'un test de *Shapiro-Wilk* et d'un test d'asym√©trie (*skewness*) :

```{r}
shapiro.test(residuals(lm1))

library(e1071)
skewness(residuals(lm1))
```
.comment[La distribution est significativement diff√©rente d'une distribution normale, d√©cal√©e vers la gauche (valeur positive d'asym√©trie)]


---

# Conditions non-respect√©es - Comment pro√©eder ?


*Il y a deux options quand les conditions d'application du mod√®le lin√©aire ne sont pas respect√©es :*

<br>

1. Utiliser un **autre type de mod√®le** mieux adapt√© √† l'hypoth√®se et aux donn√©es (ateliers 6 - 8 du CSBQ R).
<br>
<br>
2. Essayer de **transformer** la r√©ponse et / ou le pr√©dicteurs
  - Il existe **plusieurs types de transformations** et leur utilit√© d√©pend de la distribution de la variable et du type de mod√®le.
  - La transformation peut **r√©gler certains** probl√®mes mais peut en **cr√©er d'autres**.
  - Les **r√©sultats des tests de signification** sur les donn√©es transform√©es ne sont **pas automatiquement valables** pour les donn√©es non transform√©es.

???

- La transformation des variables peut √™tre utile, mais elle est souvent d√©licate en pratique

---

# D√©fi 1: Un mod√®le sur variables transform√©es ![:cube]

*Essayons de r√©soudre nos probl√®mes avec une transformation logarithmique.*

Ajoutons des variables transform√©es √† notre jeu de donn√©es :

```{r}
bird$logMaxAbund <- log10(bird$MaxAbund)
bird$logMass <- log10(bird$Mass)
```

--

#### D√©fi

**√âtape 1.** Ex√©cuter une r√©gression lin√©aire sur les variables transform√©es `logMaxAbund` et `logMass`.
Sauvegarder l'objet du mod√®le sous `lm2`

**√âtape 2**: V√©rifier les conditions pour `lm2` en utilisant les graphique diagnostics.

```{r}
lm2 <- lm(logMaxAbund ~ logMass, data = bird)
```

???

- Se r√©partir en petits groupes. Puis disctuter des r√©sultats avec l'ensemble des participant.e.s

---

# D√©fi 1: Un mod√®le sur variables transform√©es ![:cube]

**√âtape 1.** Ex√©cuter une r√©gression lin√©aire sur les variables transform√©es 

```{r}
lm2 <- lm(logMaxAbund ~ logMass, data = bird)

lm2
```

.center[
*Comment les param√®tres se comparent-ils √† nos pr√©dictions ?*
]

.center[
**Peut-on se fier aux estimations du mod√®le ?**
]

???

- Cette fois, les param√®tres s'alignent avec nos pr√©dictions.
- MAIS : Bien s√ªr, nous devons encore v√©rifier les hypoth√®ses 

---

# D√©fi 1: Un mod√®le sur variables transform√©es ![:cube]

**√âtape 2**: V√©rifier les conditions pour `lm2` 

```{r, fig.height=5.5, fig.width=7.5}
par(mfrow=c(2,2), mar=c(3,4,1.15,1.2))
plot(lm2)
```

--

.comment[.center[Beaucoup mieux, mais il reste des probl√®mes]]

???

- Il y a encore des tendances visibles dans les graphiques

---

# **√âtape 2.** V√©rifier les conditions d'application pour `lm2`

```{r, fig.height=4, fig.width=11,}
par(mfrow = c(1,2))
coef(lm2) # constante et pente
plot(logMaxAbund ~ logMass, data=bird) # graphique √† gauche
abline(lm2) # ligne d√©finie par les param√®tres du mod√®le
hist(residuals(lm2)) # graphique √† droite : distribution des r√©sidus
```

---

# **√âtape 3.** Analyser les param√®tres

La fonction `summary()` est utili√©e pour obtenir plus d'informations sure le mod√®le ajust√©. 

.small[
```{r, comment=""}
summary(lm2)
```
]

???

- Prendre le temps d'expliquer la sortie de `summary()` :
  1. Estimations des param√®tres et leur √©carts type
  2. R√©sultats d'un test de t visant √† d√©terminer si les param√®tres sont diff√©rents de 0
  3. Adjusted R squared (R au carr√© ajust√©) : Dans quelle mesure le mod√®le explique-t-il les donn√©es ?
  4. F-statistic (statistique F) (ANOVA) : Le mod√®le est-il significativement diff√©rent d'un mod√®le sans pr√©dicteur (mod√®le nul) ?
- Mentionner que les tests t et l'ANOVA seront abord√©s plus tard
- Dans ce cas : notre mod√®le est √† peine meilleur que le mod√®le nul


---

# **√âtape 3.** Analyser les param√®tres

Nous pouvons aussi extraire les param√®tres du mod√®le et des autres r√©sultats :

```{r}
# Vecteurs de r√©sidus et valeures pr√©dites
e <- residuals(lm2)
y <- fitted(lm2)

coefficients(lm2) # coefficients
summary(lm2)$coefficients # coefficients avec test de t

summary(lm2)$adj.r.squared # R au carr√© ajust√©
```

---

# Interpr√©tation du mod√®le

.center[*Dans quelle mesure le mod√®le soutient-il notre hypoth√®se ?*]

#### Hypoth√®se

> Pour diff√©rentes esp√®ces d'oiseaux, la **masse moyenne d'un individu a un effet sur l'abondance maximale** de l'esp√®ce, en raison de contraintes √©cologiques (sources de nourriture, disponibilit√© de l'habitat, etc.).


---

# Interpr√©tation du mod√®le

.center[*Dans quelle mesure le mod√®le soutient-il notre hypoth√®se ?*]

```{r, comment=""}
summary(lm2)
```

---

# Interpr√©tation du mod√®le

.center[*Dans quelle mesure le mod√®le soutient-il notre hypoth√®se ?*]

Il n'y a que tr√®s **peu de preuves √† l'appui** de notre hypoth√®se parce que :
- Le mod√®le n'explique pas bien la r√©ponse (*faible R au carr√© ajust√©*)
- Le mod√®le n'est que l√©g√®rement meilleur qu'un mod√®le sans variables pr√©dictives (*F-test √† peine significatif*)
- L'estimation du param√®tre "logMass" est √† peine diff√©rente de 0 (*valeur de t √† peine significatif*)

???

- In this case, the F-test and t-test are equivalent because there is only one predictor variable)

---

# Trouver un meilleur mod√®le : oiseaux terrestres

*Peut-√™tre devrions-nous formuler une hypoth√®se plus pr√©cise ?*

--

#### Hypoth√®se

> Pour diff√©rentes esp√®ces d'oiseaux <span style="color:green">**terrestres**</span>, la **masse moyenne d'un individu a un effet sur l'abondance maximale** de l'esp√®ce, en raison de contraintes √©cologiques (sources de nourriture, disponibilit√© de l'habitat, etc.).

---

# Trouver un meilleur mod√®le : oiseaux terrestres

Exclure tous les oiseaux aquatiques (en utilisant `!`) et ajuster un mod√®le lin√©aire¬†:

```{r}
lm3 <- lm(logMaxAbund~logMass, data=bird, subset=!bird$Aquatic)
# exclut les oiseaux aquatiques (!birdsAquatic == TRUE)
# ou de fa√ßon √©quivalente :
# lm3 <- lm(logMaxAbund~logMass, data=bird, subset=bird$Aquatic == 0)

lm3
```

---

# Trouver un meilleur mod√®le : oiseaux terrestres

```{r, eval=FALSE, fig.height=5.5, fig.width=7.5}
par(mfrow=c(2,2))
plot(lm3)
```

```{r, echo=FALSE, fig.height=5.5, fig.width=7.5}
par(mfrow=c(2,2), mar = c(4,4,2,1.1), oma =c(0,0,0,0))
plot(lm3)
```

.comment[.center[Conditions d'application respect√©es]]

---

# Trouver un meilleur mod√®le : oiseaux terrestres

.center[*Dans quelle mesure le mod√®le soutient-il notre hypoth√®se ?*]

```{r, comment=""}
summary(lm3)
```

---

# Trouver un meilleur mod√®le : oiseaux terrestres

.center[*Dans quelle mesure le mod√®le soutient-il notre hypoth√®se ?*]

Le mod√®le fournit des **preuves √† l'appui** de notre hypoth√®se, parce que :

- Le mod√®le est raisonnablement bien ajust√© aux donn√©es (*R au carr√© ajust√©*)
- Le mod√®le est clairement meilleur qu'un mod√®le sans variables pr√©dictives (*F-test*)
- L'estimation du param√®tre "logMass" est clairement diff√©rente de 0 (*t-test*)


---

# D√©fi 2 ![:cube]()

Rassemblons tout les √©tapes :

<br>
1. Formuler une autre hypoth√®se similaire sur l'abondance maximale et la masse moyenne d'un individu, cette fois pour les **passereaux** ("passerine birds").
2. Ajuster un **mod√®le** pour √©valuer cette hypoth√®se, en utilisant les variables transform√©es (c'est-√†-dire `logMaxAbund` et `logMass`). Sauvegarder le mod√®le sous le nom de `lm4`.
3. **V√©rifier les conditions d'application** du mod√®le lin√©aire √† l'aide des graphiques diagnostics.
4. Interpr√©ter les r√©sultats : Le mod√®le fournit-il des **preuves √† l'appui de l'hypoth√®se ?**


.comment[Indice : Comme les esp√®ces aquatiques, les passereaux (variable `Passerine` sont cod√©es 0/1 (v√©rifier avec `str(bird)`)]

---

# D√©fi 2 - Solution ![:cube]()

#### Hypoth√®se

> Pour diff√©rentes esp√®ces de <span style="color:green">**passereaux**</span>, la **masse moyenne d'un individu a un effet sur l'abondance maximale** de l'esp√®ce, en raison de contraintes √©cologiques (sources de nourriture, disponibilit√© de l'habitat, etc.).

---

# D√©fi 2 - Solution ![:cube]()

ajuster le mod√®le :

```{r}
lm4 <- lm(logMaxAbund ~ logMass, data=bird, subset=bird$Passerine == 1)
lm4
```

---

# D√©fi 2 - Solution ![:cube]()

V√©rifier les conditions d'application :

```{r, eval=FALSE}
par(mfrow=c(2,2))
plot(lm4)
```

```{r,fig.height=6, fig.width=8, echo=FALSE}
par(mfrow=c(2,2), mar = c(4,4,2,1.1), oma =c(0,0,0,0))
plot(lm4)
```

---

# D√©fi 2 - Solution ![:cube]()

Vaut-il la peine d'interpr√©ter les r√©sultats ?

```{r, comment=""}
summary(lm4)
```

???

- Les r√©sultats du mod√®le ne doivent pas √™tre interpr√©t√©s car les conditions d'application du mod√®le lin√©aire ne sont pas respect√©es!

---

# R√©gression lin√©aire avec R

.center[.small[
**√âtape 1**   
Formuler et ex√©cuter un mod√®le lin√©aire bas√© sur un hypoth√®se

**√âtape 2**  
V√©rifier les conditions d'application du mod√®le lin√©aire
]]

<br>

.pull-left[.center[![:faic](arrow-down)]] .pull-right[.center[![:faic](arrow-down)]]

.pull-left[.center[*Conditions sont satisfaits ?*]

.small[.center[**√âtape 3**  ]
- Analyser les param√®tres de r√©gression
- Tracer le mod√®le
- Effectuer des tests de signification sur les estimations des param√®tres (si n√©cessaire)
]]

.pull-right[.center[*Conditions non satisfaites ?*]

.center[Envisager l'utilisation d'un *Mod√®le lin√©aire g√©n√©ralis√©* (GLM) ou la transformation des donn√©es]

.pull-left[.center[![:faic](arrow-down)]] .pull-right[.center[![:faic](arrow-down)]]

.small[
.pull-left[
Utiliser un GLM mieux adapt√© aux donn√©es
]

.pull-right[
Retourner √† l'√âtape 1 avec des variables transform√©es
]]]

---

# Noms de variables

Des termes diff√©rents sont utilis√©s pour la *r√©ponse* et le *pr√©dicteur*, , en fonction du contexte et du domaine scientifique (les termes ne sont pas toujours synonymes).

<br>

.center[
|r√©sponse          | pr√©dicteur       |
|:-----------------|:-----------------|
|var. expliqu√©     |var. explicatif   |
|                  |covariable        |
|var. endog√®ne     |var. exog√®ne      |
|var. d√©pendante   |var. ind√©pendante |
]

<br>

.center[
|response          | predictor        |
|:-----------------|:-----------------|
|                  |explanatory var.  |
|                  |covariate         |
|outcome           |                  |
|output var.       |input var.        |
|dependent var.    |independent var.  |
]


---

# Mod√®les lin√©aires

.center[
![:scale 100%](images/schema_ttest.png)
]

---

class: inverse, center, middle

# ANOVA

## Test-t
## ANOVA √† un crit√®re de classification
## ANOVA √† deux crit√®res de classification

---
# ANOVA

Variable r√©ponse continue

**Variables explicatives cat√©goriques**

- Deux niveaux ou plus (groupes)

.large[.center[Compare la variation intra-groupe et inter-groupe afin de d√©terminer si les moyennes des groupes diff√©rent]]

---
# ANOVA

.center[Compare la variation intra-groupe et inter-groupe afin de d√©terminer si les moyennes des groupes diff√®rent]

```{r, echo = FALSE, fig.height=3, fig.width=6.5}
source('script/figAnova.R')
```

Somme des carr√©s : variance intra-traitement *vs* variance inter-traitement

Si variance inter traitements $>$ variance intra traitements:
  - la variable explicative a un effet plus important que l'erreur al√©atoire
  - variable explicative est donc susceptible d'influencer significativement la variable r√©ponse

---
# Types d'ANOVA

1. ANOVA √† un crit√®re de classification
  - Une variable explicative cat√©gorique avec au moins 2 niveaux
  - S'il y a 2 niveaux, un **test de t** peut √™tre utilis√© alternativement

2. ANOVA √† deux crit√®res de classification
  - Deux variables explicatives cat√©goriques ou plus
  - Chaque facteur peut avoir plusieurs niveaux
  - Les interactions entre chaque facteur doivent √™tre test√©es

--

Mesures r√©p√©t√©es ?
  - L'ANOVA peut √™tre utilis√©e pour des mesures r√©p√©t√©es, mais ce sujet n'est pas abord√© dans cet atelier
  - Mod√®le lin√©aire mixte peut √©galement √™tre utilis√© pour ce type de donn√©es (voir l'atelier 6)

---
class: inverse, center, middle

# Test de t

---
# Test de t

- **Variable r√©ponse** ![:faic](arrow-right) quantitative
- **Variable explicative** ![:faic](arrow-right) qualitative avec **2 niveaux**

**conditions d'application**
- Les r√©sidus suivent une distribution normale
- Les variances des groupes sont homog√®nes

.comment[Le test est plus robuste lorsque la taille de l'√©chantillon est plus √©lev√©e et lorsque les groupes ont des tailles √©gales]

---
# Ex√©cuter un test de t dans R

Vous pouvez utiliser la fonction `t.test()`

```r
t.test(Y ~ X2, data= data, alternative = "two.sided")
```

  - `Y`: variable r√©ponse
  - `X2`: facteur (2 niveaux)
  - `data`: nom du jeu de donn√©es
  - hypoth√®se `alternative` : `"two.sided"` (par d√©faut), `"less"`, ou `"greater"`

Le test de t est un mod√®le lin√©aire et un cas sp√©cifique de l'ANOVA avec un facteur √† 2 niveaux

Vous pouvez donc aussi utiliser la fonction `lm()`

```r
lm.t < -lm(Y ~ X2, data = data)
anova(lm.t)
```

---
# Ex√©cuter un test de t dans R

.large[Les oiseaux aquatiques sont-ils plus lourds que les oiseaux terrestres ?]

- Variable r√©ponse : `Bird mass` ![:faic](arrow-right) num: continue
- Variable explicative : `Aquatic` ![:faic](arrow-right) 2 niveaux : 1 ou 0 (oui ou non)

---
# Ex√©cuter un test de t dans R

Premi√®rement, visualiser les donn√©es √† l'aide de la fonction `boxplot()`

```{r eval=TRUE,fig.height=5.2, fig.width=6.5}
boxplot(logMass ~ Aquatic,
        data = bird, names = c("Non aquatique", "Aquatique"))
```

---
# Ex√©cuter un test de t dans R

Testons l'homog√©n√©it√© des variances avec la fonction `var.test()`

```{r}
var.test(logMass ~ Aquatic, data = bird)
```

.comment[Le rapport des variances n'est pas statistiquement diff√©rent de 1, celles-ci peuvent donc √™tre consid√©r√©es comme √©gales]

.comment[Nous pouvons maintenant proc√©der au test de t !]

---
# Ex√©cuter un test de t dans R

```{r}
ttest1 <- t.test(logMass ~ Aquatic, var.equal = TRUE, data = bird)

# Or use lm()
ttest.lm1 <- lm(logMass ~ Aquatic, data=bird)
```

.comment[Sp√©cifie que l'homog√©n√©it√© des variances est respect√©e]

V√©rifiez que `t.test()` et `lm()` donnent le m√™me mod√®le :

```{r}
ttest1$statistic^2
anova(ttest.lm1)$`F value`
# r√©ponse : F=60.3845 dans les deux cas
```

.comment[Lorsque la condition d'√©galit√© de variance est confirm√©e, t^2 = F]

---
# Ex√©cuter un test de t dans R

Si $p<0,01$ (ou $0,05$ ), l'hypoth√®se de l'absence de diff√©rence entre les moyenne des 2 groupes (*H0*) peut √™tre rejet√©e, avec un risque de $0,01$ (ou $0,05$ ) de se tromper

.small[
```{r}
ttest1
```
]

.small[.comment[Il existe une diff√©rence entre la masse des oiseaux aquatiques et terrestres - `p-value`]]

.small[.comment[Regardez les moyennes des 2 groupes]]

---
# Non respect des conditions d'application

- **Correction de Welch** : lorsque les √©carts entre les groupes ne sont pas √©gaux (par d√©faut dans R !)
- **Test de Mann-Whitney** : l'√©quivalent **non param√©trique** du test de t lorsque les conditions d'application ne sont pas respect√©es
- **Test de t appari√©** : lorsque les deux groupes ne sont **pas ind√©pendants** (par exemple, des mesures sur la m√™me personne r√©colt√©es lors de 2 ann√©es diff√©rentes)

---
exclude:True
# Discussion de groupe

.large[Les oiseaux aquatiques sont-ils plus lourds que les oiseaux terrestres ?]

```{r}
# Unilateral t-test
uni.ttest1 <- t.test(logMass ~ Aquatic,
                     var.equal = TRUE,
                     data = bird,
                     alternative = "less")
```

.comment[Qu'avez-vous conclu ?]

---
exclude:True
# Discussion de groupe

```{r}
uni.ttest1
```

Oui, les oiseaux aquatiques sont plus lourds que les oiseaux terrestres :p-value = `r format(uni.ttest1$p.value, scientific=FALSE)`
---
# Sondage

.large[Avec un test de t, il est possible d'√™tre plus pr√©cis et de donner une direction √† notre hypoth√®se avec `alternative`.] 
<br>
<br>
<br>
Nous voulons tester si **les oiseaux aquatiques sont plus lourds que les oiseaux terrestres **. 

Lequel devrait √™tre utilis√©? `alternative = "???"`

1.`"two.sided"`

2.`"less"`

3.`"greater"`

```{r,eval=F,echo=T}
# Unilateral t-test
uni.ttest1 <- t.test(logMass ~ Aquatic,
                     var.equal = TRUE,
                     data = bird,
                     alternative = "???")
```

---
# R√©ponse

.xsmall[
```{r}
# Unilateral t-test
uni.ttest1 <- t.test(logMass ~ Aquatic,
                     var.equal = TRUE,
                     data = bird,
                     alternative = "less")
uni.ttest1

```
]

Pourquoi `"greater"` n'aurait pas march√©?

.comment[Indice: retournez √† vos donn√©es. Quelle est la nature de la variable Aquatic?]

???

Presenter notes: To understand this answer, we have to understand the dataset. Aquatic is binary variable, i.e. that 0 = terrestrial birds, and 1 = aquatic birds. By default, R will always test in this order. So, we are actually testing whether terrestrial birds are lighter than aquatic birds. This is also points out the importance to understand your dataset.

---
class: inverse, center, middle

# ANOVA

---
# Analyse de Variance (ANOVA)

G√©n√©ralisation du test de t √† $>2$ groupes, et/ou ‚â• $2$ facteurs explicatifs

D√©composition de la variance observ√©e de la variable r√©ponse en effets additifs d'un ou de plusieurs facteurs et de leurs interactions

<br>
$$Y = \underbrace{\mu}_{\Large{\text{moyenne globale de la variable r√©ponse}\atop\text{sur tous les individus}}} + \overbrace{\tau_{i}}^{\Large{\text{Le r√©sultat moyen sur}\atop\text{tous les individus du groupe i}}} + \underbrace{\epsilon}_{\text{R√©sidus}}$$

---
# Rappel : ANOVA

conditions d'application
- Normalit√© des r√©sidus
- L'√©galit√© de la variance inter-groupes

Test compl√©mentaire
- Lorsque l'ANOVA d√©tecte une diff√©rence significative entre les groupes, l'analyse n'indique pas quel(s) groupe(s) diff√®re(nt) de(s) l'autre(s)
- Un test couramment utilis√© *a posteriori* pour r√©pondre √† cette question est le **Test de Tukey**

---
# Ex√©cuter une ANOVA dans R

##### Est-ce que l'abondance maximale d√©pend du r√©gime alimentaire ?
- Variable r√©ponse : **MaxAbund**  ![:faic](arrow-right) num: quantitative
- Variable explicative : **Diet** ![:faic](arrow-right) facteur avec 5 niveaux

```{r}
str(bird)
```

---
# Visualiser les donn√©es

Visualisons tout d'abord les donn√©es avec la fonction `boxplot()`

```{r, fig.height=5, fig.width=7,echo=-1}
par(mar = c(4, 4, 0.5, 1))
boxplot(logMaxAbund ~ Diet, data = bird,
  ylab = expression("log"[10]*"(Abondance maximale)"), xlab = 'R√©gime alimentaire')
```

---
# Visualiser les donn√©es

Nous pouvons changer l'ordre des niveaux afin qu'il suivent l'ordre croissant de leurs m√©dianes respectives en utilisant les fonctions `tapply()` et `sort()`

```{r, fig.height = 4.5, fig.width = 7, echo = -1}
par(mar = c(4, 4, .1, 1))
med <- sort(tapply(bird$logMaxAbund, bird$Diet, median))
boxplot(logMaxAbund ~ factor(Diet, levels = names(med)), data = bird,
        ylab = expression("log"[10]*"(Abondance maximale)"), xlab = 'R√©gime alimentaire')
```

---
# Visualiser les donn√©es


Une autre fa√ßon de visualiser graphiquement les tailles d‚Äôeffet est d‚Äôutiliser la fonction `plot.design()`

.small[
```{r, fig.height=3.8, fig.width=6, echo=-1}
par(mar = c(4,4,.4,1))
plot.design(logMaxAbund ~ Diet, data = bird,
  ylab = expression("log"[10]*"(Abondance maximale)"))
```
]

.comment[Les niveaux d'un facteur le long d'une ligne verticale, et la valeur globale de la r√©ponse dans une ligne horizontale]

---
# ANOVA √† un crit√®re de classification dans R

Il est de nouveau possible d'utiliser la fonction `lm()`

```{r}
anov1 <- lm(logMaxAbund ~ Diet,
            data = bird)
```

Il y a aussi une fontion sp√©cifique pour l'analyse de la variance dans R `aov()`

```{r}
aov1 <- aov(logMaxAbund ~ Diet,
            data = bird)
```

.comment[Essayez-les et comparez les sorties !]

---
# Ex√©cuter une ANOVA

#### √Ä un crit√®re de classification dans R

Comparer les sorties

```{r}
anova(anov1)
```
```{r}
summary(aov1)
```

---
# V√©rifier les conditions d'application

**Test de Bartlett**: √©galit√© de la variance entre les groupes

.small[
```{r}
bartlett.test(logMaxAbund ~ Diet, data = bird)
```
]
---
# V√©rifier les conditions d'application


**Test de Levene** pour l'homog√©n√©it√© de la variance:

.small[
```{r}
library(car)
leveneTest(logMaxAbund ~ Diet, data = bird)
```
]

.comment[Le test de Levene performe mieux, mais a une erreur de Type II un peu plus √©lev√©e.]

---
#V√©rifier les conditions d'application

**Test de Shapiro-Wilk**:  normalit√© des r√©sidus

.small[
```{r}
shapiro.test(resid(anov1))
```
]

.comment[Les deux tests sont non-significatifs; les r√©sidus du mod√®le peuvent √™tre consid√©r√©s normaux et les variances homog√®nes]

---
# Et si les conditions d'application ne sont pas respect√©es...

**Transformer vos donn√©es** : pourrait √©galiser les variances et normaliser les r√©sidus, et peut convertir un effet multiplicatif en un effet additif

```{r eval=FALSE}
data$logY <- log10(data$Y)
```
* Voir le wiki de l'atelier 1 pour les r√®gles de transformation de donn√©es
* r√©-ex√©cuter votre mod√®le avec la variable transform√©e et v√©rifier √† nouveau les hypoth√®ses

**Test de Kruskal-Wallis**: √©quivalent non param√©trique de l'ANOVA si vous ne pouvez pas
(*ou ne voulez pas*) transformer les donn√©es

```{r eval=FALSE}
kruskal.test(Y~X, data)
```

---
# Sorties de notre mod√®le ANOVA

Triage en ordre alphab√©tique des niveaux et comparaison au niveau de r√©f√©rence (`Insect`)

.xsmall[
```{r}
summary(anov1)
```
]

---
# Sorties de notre mod√®le ANOVA

D'autre part, si nous utilisons `lm()`

.pull-left2[
.small[
```{r}
summary.lm(aov1)
```
]]

.pull-right2[
<br><br>
.comment[Diff√©rence significative entre les groupes, mais nous ne savons pas lesquels !]]

---
# Test *a posteriori*

Lorsque l'ANOVA d√©tecte un effet significatif de la variable explicative, un test post-hoc avec la fonction `TukeyHSD()`, doit √™tre effectu√© pour d√©terminer quel(s) tratement(s) diff√®re(nt)

.pull-left2[
.small[
```{r}
TukeyHSD(aov(anov1), ordered = TRUE)
```
]]

.pull-right2[
<br><br>
.comment[Seuls `Vertebrate` et `PlantInsect` diff√®rent]
]

---
# Repr√©sentation graphique

Repr√©sentation graphique de l'ANOVA √† l'aide de la fonction `barplot()`

.xsmall[
```{r, fig.height=3, fig.width=7,echo=-1}
par(mar=c(3,3,0.5,0.5))
sd <- tapply(bird$logMaxAbund, bird$Diet, sd)
means <- tapply(bird$logMaxAbund, bird$Diet, mean)
n <- length(bird$logMaxAbund)
se <- 1.96*sd/sqrt(n)
bp <- barplot(means, ylim = c(0, max(bird$logMaxAbund) - 0.5))
epsilon = 0.1
segments(bp, means - se, bp, means + se, lwd=2) # barres verticales
segments(bp - epsilon, means - se, bp + epsilon, means - se, lwd = 2) # barres horizontales
segments(bp - epsilon, means + se, bp + epsilon, means + se, lwd = 2) # barres horizontales
```
]

---
class: inverse, center, middle

# ANOVA √† deux crit√®res de classification

---
# ANOVA √† deux crit√®res de classification

Plus d'un facteur

- ANOVA avec un facteur:

 `aov <- lm(Y ~ X, data)`

- ANOVA avec deux ou plus facteurs:

 `aov <- lm(Y ~ X * Z * ..., data)`

.comment[Lorsque vous utilisez le symbole "*" avec `lm()`, le mod√®le inclut les effets de chaque facteur s√©par√©ment, ainsi que leur interaction]
<br>
<br>
.comment[Lorsque vous utilisez le symbole "+" avec `lm()`, le mod√®le inclut les effets de
chaque facteur s√©par√©ment (pas d'interaction)]

`aov <- lm(Y ~ X + Z + ..., data)`

---
# ANOVA √† deux crit√®res de classification

.small[

Exemple d'interaction non significative

```r
aov <- lm(Y ~ X * Z, data)
summary(aov)
# Analysis of Variance Table
#
# Response: Y
# Df Sum Sq Mean Sq F value Pr(>F)
# X 4 5.1059 1.27647 3.0378 0.02669 *
# Z 1 0.3183 0.31834 0.7576 0.38870
# X:Z 3 2.8250 0.94167 2.2410 0.10689
# Residuals 45 18.9087 0.42019
# ---
# Signif. codes: 0 ‚Äò***‚Äô 0.001 ‚Äò**‚Äô 0.01 ‚Äò*‚Äô 0.05 ‚Äò.‚Äô 0.1 ‚Äò ‚Äô 1
```

Selon le principe de **parcimonie**, vous voulez que votre mod√®le explique le plus possible de la variance observ√©e dans les donn√©es, avec le moins de termes possible
- Enlever le terme d'interaction s'il n'est pas significatif, et r√©-ex√©cuter le mod√®le

```r
aov <- lm(Y ~ X + Z, data)
```
]

---
exclude:true
# D√©fi 3 ![:cube]()

Testez si l'abondance maximale `log(MaxAbund)` varie √† la fois en fonction du r√©gime alimentaire (`Diet`) et de l'habitat (`Aquatic`).

.comment[INDICE: Examinez les facteurs Diet, Aquatic et leur interaction avec une ANOVA √† deux crit√®res de classification e.g. `lm(Y ~ A*B)`]

.comment[o√π A est le premier facteur, B le deuxi√®me et "\*" d√©crit l'interaction]

---
# D√©fi 3 ![:cube]()

Testez si l'abondance maximale `log(MaxAbund)` varie √† la fois en fonction du r√©gime alimentaire (`Diet`) et de l'habitat (`Aquatic`).
<br>
<br>
.comment[INDICE: Assurez-vous d'ajouter une interaction avec `*`]
<br>
<br>
<br>
<br>
.large[
.center[
.alert[Salle de r√©union!]
]]

---
# ![:cube]()

.xsmall[
```{r}
anov2 <- lm(logMaxAbund ~ Diet*Aquatic, data = bird)
summary(anov2)
```
]

---
# D√©fi 3 - Solution ![:cube]()

.xsmall[
```{r}
anov2 <- lm(logMaxAbund ~ Diet*Aquatic, data = bird)
anova(anov2)
```
]

.comment[Le seul terme significatif du mod√®le est le facteur r√©gime alimentaire]

.comment[Selon le principe de parcimonie, nous devrions supprimer le terme d'interaction:]

```r
anov2 <- lm(logMaxAbund ~ Diet, data = bird)
```

---
# Mod√®les lin√©aires

.center[
![:scale 100%](images/schema_ancova.png)
]

---
class: inverse, center, middle

# ANCOVA

---
# Analyse de covariance (ANCOVA)

- Combinaison de l'ANOVA et de la r√©gression lin√©aire
- Les variables explicatives sont un m√©lange de variables quantitatives (covariable) et qualitatives (facteurs)

$$Y = \mu + \text{Effets principaux des facteurs} + \\
            \text{Interactions entre facteurs} + \\
            \text{Effets principaux des covariables} + \\
            \text{Interactions entre covariables et facteurs} + \epsilon$$

---
# Rappel : ANCOVA

En plus des conditions d'application des mod√®les lin√©aires, les mod√®les **ANCOVA** doivent respecter :

- Les covariables ont toutes la **m√™me √©tendue de valeurs**
- Les variables sont **fixes**
- Les variables cat√©goriques et continues sont **ind√©pendantes**

<br>

.small[
.comment[Un variable **fixe** est une variable d'int√©r√™t pour une √©tude (e.g. la masse des oiseaux). En comparaison, une variable al√©atoire repr√©sente surtout une source de bruit qu'on veut contr√¥ler (i.e. le site o√π les oiseaux ont √©t√© √©chantillonn√©s)]]

.small[.comment[*Voir l'atelier 6 sur les mod√®les lin√©aires mixtes*]]

---
# Types d'ANCOVA

Vous pouvez avoir n'importe quel nombre de facteurs et / ou variables, mais lorsque leur nombre augmente, l'interpr√©tation des r√©sultats devient de plus en plus complexe

<br>

ANCOVA fr√©quemment utilis√©es

1. **Une covariable et un facteur**
2. Une covariable et deux facteurs
3. Deux covariables et un facteur

.small[.comment[Nous ne consid√©rerons que le premier cas aujourd'hui, mais les deux autres sont similaires]]

---
# ANCOVA avec 1 covariable et 1 facteur

Objectifs de l'analyse :

1. D√©terminer l'effet du facteur et de la covariable sur ‚Äã‚Äãla variable r√©ponse
2. D√©terminer l'effet du facteur sur la variable r√©ponse apr√®s avoir enlev√© l'effet de la covariable
3. D√©terminer l'effet de la covariable sur la variable r√©ponse en contr√¥lant l'effet du facteur

<br>

.center[.alert[Si vous avez une interaction significative entre votre facteur et votre covariable, vous ne pouvez pas atteindre ces objectifs !]]

---
# ANCOVA avec 1 covariable et 1 facteur

<br>

```{r,echo=FALSE,fig.height=3, fig.width=10}
## functions
f1 <- function(x, a, b) {
  return(x*a+b)
}
# conf for plot
col = rgb(118, 143, 175, maxColorValue = 255)
x <- 1:20
par(mfrow = c(1, 3), mar = c(1, 1, 6.5, 4))

# plot 1
plot(x, f1(x, a=1.1,b=2), ylim = c(0, 60), type = 'l', lwd = 2.5, xaxt = "n", yaxt = "n", xlab = "", ylab = "", bty='l', col = col)
lines(f1(x, a=1.1,b=17), lwd = 2.5, col = col)
lines(f1(x, a=0.6,b=22), lwd = 2.5, col = col)
lines(f1(x, a=1.1,b=40), lwd = 2.5, col = col)
mtext('Un niveau du facteur\n a une pente diff√©rente', side = 3, line = 2, cex = 1.5)
# plot 2
plot(x, f1(x, a=.5,b=2), ylim = c(0, 60), type = 'l', lwd = 2.5, xaxt = "n", yaxt = "n", xlab = "", ylab = "", bty='l', col = col)
lines(f1(x, a=1.1,b=17), lwd = 2.5, col = col)
lines(f1(x, a=1.1,b=22), lwd = 2.5, col = col)
lines(f1(x, a=0.01,b=40), lwd = 2.5, col = col)
mtext('Des nombreaux niveaux ont\n des pentes diff√©rentes', side = 3, line = 2, cex = 1.5)
# plot 3
plot(x, f1(x, a=1.1,b=2), ylim = c(0, 60), type = 'l', lwd = 2.5, xaxt = "n", yaxt = "n", xlab = "", ylab = "", bty='l', col = col)
lines(f1(x, a=1.1,b=17), lwd = 2.5, col = col)
lines(f1(x, a=1.1,b=22), lwd = 2.5, col = col)
lines(f1(x, a=1.1,b=40), lwd = 2.5, col = col)
mtext("Pas d'interaction", side = 3, line = 2, cex = 1.5)
```

.pull-left2[.center[.pull-left[![:faic](arrow-up)] .pull-right[![:faic](arrow-up)]]] .pull-right2[.center[![:faic](arrow-up)]]

.center[.pull-left2[.small[Si l'interaction est significative, vous aurez un sc√©nario qui ressemble √† ceci]]]

.pull-right2[.small[Si votre covariable et votre facteur sont significatifs, vous avez un cas comme celui-ci]]

---
# Comparez ANCOVA - moyennes ajust√©es

Si vous voulez comparer les moyennes des diff√©rents facteurs, vous pouvez utiliser les
**moyennes ajust√©es**

La fonction `effect()` utilise les √©quations donn√©es par l'ANCOVA pour estimer les moyennes de chaque niveau, corrig√©es pour l'effet de la covariable

.small[
```{r eval=FALSE, warning=FALSE}
ancova.exemple <- lm(Y ~ X*Z, data=data) # X = quantitative; Z = qualitative
library(effects)
adj.means.ex <- effect('Z', ancova.exemple)
plot(adj.means.ex)
```
]

```{r,echo=FALSE, fig.height=3, fig.width=5}
# plot to simulate effects::effect() plot
a = 40; b =20; sd = 8
par(mar=c(4,4,.5,1))
plot(c(a, b), ylim = c(10, 50), xlim = c(0.9, 2.1), xlab = 'factor Z', ylab = 'Y', xaxt = 'n')
lines(c(a, b), col = 4, pch = 1.5)
segments(c(1, 2), c(a-sd, b-sd), c(1,2), c(a+sd, b+sd), lwd = 1.5, col = 'orange')
segments(c(1, 2) - .04, c(a, b) + sd, c(1, 2) + .04, c(a, b) + sd, lwd = 1.5, col = 'orange')
segments(c(1, 2) - .04, c(a, b) - sd, c(1, 2) + .04, c(a, b) - sd, lwd = 1.5, col = 'orange')
points(c(1, 2), c(a, b), pch = 16, col = 4)
axis(1, at = c(1, 2), labels = FALSE) # add ticks
mtext(c('Level 1', 'Level 2'), 1, at = 1:2, line = 0.5) # add labels to ticks
```

---
# ANCOVA avec 1 covariable et 1 facteur

- Si seulement votre facteur est significatif, √©liminer la covariable -> vous avez une **ANOVA**
- Si seulement votre covariable est significative, √©liminer le facteur -> vous avez une **r√©gression lin√©aire simple**
- Si votre interaction covariable * facteur est significative, vous voudrez peut-√™tre tester quel(s) niveau(x) du facteur a(ont) des pentes diff√©rentes

.alert[V√©rifier vos conditions d'application ! ]

- Tr√®s similaire √† ce que vous avez fait pr√©c√©demment

---
# Ex√©cuter une ANCOVA dans R

##### L'abondance maximale varie-t-elle en fonction du r√©gime alimentaire et la masse des oiseaux ?

Variable r√©ponse : **MaxAbund** ![:faic](arrow-right) num : quantitative continue

Variable explicatives :
  - **Diet** ![:faic](arrow-right) facteur √† 5 niveaux
  - **Mass** ![:faic](arrow-right) num√©rique continue

.small[
```{r}
str(bird)
```
]

---
exclude: true
# D√©fi 4 ![:cube]()

1- Ex√©cutez un mod√®le pour tester les effets du r√©gime alimentaire (`Diet`), de la masse (`logMass`) ainsi que leur interaction sur l'abondance maximale des oiseaux (`logMaxAbund`)

```{r eval=FALSE}
ancova.exemple <- lm(Y~X*Z, data=data)
summary(ancova.exemple)
```

2- V√©rifiez si votre interaction est significative

```{r eval=FALSE}
ancova.exemple2 <- lm(Y~X+Z, data=data)
summary(ancova.exemple2)
```
---

# D√©fi 4 ![:cube]()

1- Ex√©cutez un mod√®le pour tester les effets du r√©gime alimentaire (`Diet`), de la masse (`logMass`) ainsi que leur interaction sur l'abondance maximale des oiseaux (`logMaxAbund`)

<br>

2- V√©rifiez si votre interaction est significative
<br>
<br>
<br>
<br>

.large[
.center[
.alert[Salle de r√©union!]
]]
---
# D√©fi 4 - Solution ![:cube]()

<br>

```{r}
ancov1 <- lm(logMaxAbund ~ logMass*Diet,
             data = bird)
anova(ancov1)
```

Interaction entre `logMass` et `Diet` n'est pas significative

---
# D√©fi 4 - Solution ![:cube]()

√âliminer le terme d'interaction, puis r√©-√©valuer le mod√®le contenant les effets simples de `logMass` et `Diet`

```{r}
ancov2 <- lm(logMaxAbund ~ logMass + Diet,
             data = bird)
anova(ancov2)
```

---

# Mod√®les lin√©aires

.center[
![:scale 100%](images/schema_multReg.png)
]

---

class: inverse, center, middle

# R√©gression lin√©aire multiple

---

# R√©gression lin√©aire multiple
- **Variables explicatives** ![:faic](arrow-right) 2 ou plusieurs variables continues
- **Variable r√©ponse** ![:faic](arrow-right) 1 variable continue

.xsmall[Seule diff√©rence avec la r√©gression lin√©aire simple : **plusieurs variables explicatives** sont incluses dans le mod√®le.] 

#### Variables

- $y$ : Variable r√©ponse (**continue**)
- $x$ : Plusieurs variables explicatives (**continues** ou **cat√©goriques**)

#### Relation suppos√©e

$$y_i = \beta_0 + \beta_1x_{1,i}+\beta_2x_{2,i}+\beta_3x_{3,i}+...+\beta_kx_{k,i} + \epsilon_i$$

- Le param√®tre $\beta_0$ est **l'ordonn√©e √† l'origine** (ou constante)
- Les param√®tre $\beta_1$ quantifie **l'effet** de $x$ sur $y$.
- Le r√©sidu $\epsilon_i$ repr√©sent la variation **non expliqu√©e**
- La **valeur pr√©dite** de $y_i$ se d√©finit comme : $\hat{y}_i = \beta_0 + \beta_1x_{1,i}+\beta_2x_{2,i}+\beta_3x_{3,i}+...+\beta_kx_{k,i}$.

---

# R√©gression lin√©aire multiple


$$y_i = \beta_0 + \beta_1x_{1,i}+\beta_2x_{2,i}+\beta_3x_{3,i}+...+\beta_kx_{k,i} + \epsilon_i$$

$$\epsilon_i \sim \mathcal{N}(0,\,\sigma^2)$$


#### Conditions d'application

En plus des conditions d'application habituelles des mod√®les lin√©aires :
- **Relation lin√©aire** entre **chaque** variable explicative et la variable r√©ponse.
- Les variables explicatives sont ind√©pendantes les unes des autres (il n'y a pas de **colin√©arit√©**).

---

# R√©gression lin√©aire multiple


$$y_i = \beta_0 + \beta_1x_{1,i}+\beta_2x_{2,i}+\beta_3x_{3,i}+...+\beta_kx_{k,i} + \epsilon_i$$

$$\epsilon_i \sim \mathcal{N}(0,\,\sigma^2)$$



#### En cas de colin√©arit√©

- Garder seulement une des variables colin√©aires
- Essayer une analyse multidimensionnelle (voir l'atelier 9)
- Essayer une analyse pseudo-orthogonale

---


#  R√©gression lin√©aire multiple dans R

En utilisant le jeu de donn√©es `Dickcissel` comparez l'importance relative du climat (`clTma`), de la productivit√© (`NDVI`) et de la couverture du sol (`grass`) comme pr√©dicteurs de l'abondance de dickcissels (`abund`)

.small[
```{r, eval=TRUE}
Dickcissel = read.csv("data/dickcissel.csv")
str(Dickcissel)
```
]

---
# V√©rifier les conditions d'application

La colin√©arit√© :
- V√©rifier la colin√©arit√© de toutes les variables explicatives et d'int√©r√™t

.small[
.pull-left[
```{r, fig.height=6, fig.width=7}
# select variables
var <- c('clTma', 'NDVI', 'grass', 'abund')
plot(Dickcissel[, var])
```
]]

.pull-right[
<br>
.small[.comment[
Si vous observez un patron entre vos deux variables explicatives, elles peuvent √™tre colin√©aires!

Vous devez √©viter ceci, sinon leurs effets sur la variable r√©ponse seront confondus
]]]

---
# R√©gression lin√©aire multiple dans R

Ex√©cuter la r√©gression multiple de l'abondance (`abund`) en fonction des variables `clTma + NDVI + grass`

```{r,eval=FALSE}
lm.mult <- lm(abund ~ clTma + NDVI + grass, data = Dickcissel)
summary(lm.mult)
```

V√©rifiez les autres conditions d'application, comme pour la r√©gression lin√©aire simple

```{r,eval=FALSE,echo=-2}
par(mfrow = c(2, 2))
par(mfrow=c(2,2), mar = c(3.9,4,1.2,1.1), oma =c(0,0,0,0))
plot(lm.mult)
```

---
# R√©gression lin√©aire multiple dans R

Ex√©cuter la r√©gression multiple de l'abondance (`abund`) en fonction des variables `clTma + NDVI + grass`

.small[
```{r}
lm.mult <- lm(abund ~ clTma + NDVI + grass, data = Dickcissel)
summary(lm.mult)
```
]

---
# R√©gression lin√©aire multiple dans R

V√©rifiez les autres conditions d'application, comme pour la r√©gression lin√©aire simple

```{r, fig.height=5.5, fig.width=8,echo=-2}
par(mfrow = c(2, 2))
par(mfrow=c(2,2), mar = c(3.9,4,1.2,1.1), oma =c(0,0,0,0))
plot(lm.mult)
```

---

# Quel est le meilleur mod√®le ?

.small[
Souvenez-vous du principe de parcimonie: expliquer le plus de variation avec le plus petit nombre de termes dans votre mod√®le ![:faic](arrow-right) enlevez la variable qui est la moins significative
]


```{r}
summary(lm.mult)$coefficients
```

<br>

Les 3 variables sont importantes. On garde tout !

Le mod√®le explique 11.28% de la variabilit√© de l'abondance de dickcissels $R¬≤_{adj} = 0.11$.

--

.alert[Toutefois, ces informations ne sont pas valables car les conditions d'application du mod√®le lin√©aire ne sont pas respect√©es.]


---
# Quel est le meilleur mod√®le ?

Il est important de noter que la variable r√©ponse ne varie pas de fa√ßon lin√©aire avec les variables explicatives

```{r, fig.height=3.5, fig.width=11,echo=-1}
par(mfrow=c(1,3), mar=c(4, 4, 0.5, 0.5), cex = 1)
plot(abund ~ clTma, data = Dickcissel)
plot(abund ~ NDVI,  data = Dickcissel)
plot(abund ~ grass, data = Dickcissel)
```

.comment[Voir la **section avanc√©e** sur la **r√©gression polynomiale** pour la solution !]

---
class: inverse, center, middle

# Optionnel

## *si le temps le permet*

---
# Optionnel

1. Interpr√©tation des contrastes
2. ANOVA non √©quilibr√©e
3. R√©gression polynomiale
4. Partitionnement de la variation

---
exclude:true

class: inverse, center, middle

# R√©gression pas √† pas

---
exclude:true

# R√©gression pas √† pas

Ex√©cuter un mod√®le avec tout dedans sauf les variables de "Pr√©sent/absence"

La fonction `step()` soustrait un terme au mod√®le de fa√ßon it√©rative et s√©lectionne le meilleur mod√®le
  - c-√†.d. le mod√®le avec le Crit√®re d'Information Akaike (AIC) le plus bas

.small[
```{r,eval=FALSE}
lm.full <- lm(abund ~ . - Present,
              data = Dickcissel)
lm.step <- step(lm.full)
```
]
```{r,include=FALSE}
lm.full <- lm(abund ~ . - Present,
              data = Dickcissel)
lm.step <- step(lm.full)
```

---
exclude:true

# R√©gression pas √† pas

.pull-left[
.tiny[
```{r eval=TRUE}
summary(lm.full)
```
]]

.pull-right[

Variables s√©lection√©es par `step()`
.tiny[
```{r}
summary(lm.step)
```
]]

.small[.comment[Le mod√®le explique maintenant 31,44% de la variabilit√© de l'abondance de Dickcissel]]

---
class: inverse, center, middle

# Interpr√©tation des contrastes

---
# Interpr√©tation des contrastes

.small[
Les constrastes servent √† comparer chaque niveau du facteur √† un niveau de r√©f√©rence, et de d√©tecter des diff√©rences significatives entre chaque niveau.

L'estimation de l'ordonn√©e √† l'origine est le niveau de r√©f√©rence et correspond √† la moyenne du premier niveau (en ordre alphab√©tique) du facteur `Diet`

Calculez l'ordonn√©e √† l'origine de r√©f√©rence + l'ordonn√©e √† l'origine de chaque niveau de Diet .comment[*Que remarquez-vous ?*]

```{r}
tapply(bird$logMaxAbund, bird$Diet, mean)
coef(anov1)
coef(anov1)[1] + coef(anov1)[2] # InsectVert
coef(anov1)[1] + coef(anov1)[3] # Plant
```
]

---
# Interpr√©tation des contrastes

Il se peut que vous vouliez d√©finir un niveau de r√©f√©rence diff√©rent

1. Comparez le niveau `Plant` √† tous les autres niveaux du facteur `Diet`

```{r,eval=FALSE}
bird$Diet2 <- relevel(bird$Diet, ref="Plant")
anov2 <- lm(logMaxAbund ~ Diet2, data = bird)
summary(anov2)
anova(anov2)
```

2. Ordonner les niveaux selon leur m√©diane

```{r,eval=FALSE}
bird$Diet2 <- factor(bird$Diet, levels=names(med))
anov2 <- lm(logMaxAbund ~ Diet2,
            data = bird)
summary(anov2)
anova(anov2)
```

.comment[Observez-vous un changement quant aux niveaux du facteur `Diet` qui sont significatifs ?]

---
# Interpr√©tation des contrastes

.comment[Un point important √† remarquer √† propos du contraste par d√©faut dans R (`contr.treatment`) est qu'il n'est PAS orthogonal]

Pour √™tre orthogonal :
  - Pour √™tre orthogonal, les propri√©t√©s suivantes doivent √™tre respect√©es:
  - La somme du produit de deux colonnes √©gale 0

```{r}
sum(contrasts(bird$Diet)[,1])
sum(contrasts(bird$Diet)[,1]*contrasts(bird$Diet)[,2])
```

???

Note aux pr√©sentateurs:Deux contrastes sont orthogonaux si la somme des produits de leurs coefficients est nulle. 

---
# Interpr√©tation des contrastes

Changez les contrastes pour mettre les niveaux orthogonaux

.small[
```{r}
options(contrasts=c("contr.helmert", "contr.poly"))
sum(contrasts(bird$Diet)[,1])
sum(contrasts(bird$Diet)[,1]*contrasts(bird$Diet)[,2])
```
]
.pull-left[
.tiny[
```{r}
anov3 <- lm(logMaxAbund ~ Diet, data = bird)
summary(anov3)
```
]]
.pull-right[
.small[Les contrastes Helmert vont contraster le deuxi√®me niveau avec le premier, le troisi√®me avec la moyenne des deux premiers niveaux, etc.]
]

---
class: inverse, center, middle

# ANOVA non √©quilibr√©e

---
# ANOVA non √©quilibr√©e

Un jeu de donn√©es est consid√©r√© non √©quilibr√© lorsque le nombre d'√©chantillons entre deux niveaux n'est pas √©gal.

Le jeu de donn√©es `Birdsdiet` est en r√©alit√© non √©quilibr√© (le nombre d'esp√®ces aquatiques n'√©gale pas le nombre d'esp√®ces non-aquatiques)

```{r}
table(bird$Aquatic)
```

Dans une telle situation, l'ordre des covariable affecte la calculation de la somme des carr√©s, et donc la valeur de `p`. 

Testons-le avec le jeu de donn√©es `Birdsdet`.

```{r}
unb.anov1 <- lm(logMaxAbund ~ Aquatic + Diet, data = bird)
unb.anov2 <- lm(logMaxAbund ~ Diet + Aquatic, data = bird)
```

---
# ANOVA non √©quilibr√©e

```{r}
anova(unb.anov1)
```

```{r}
anova(unb.anov2)
```

---
# ANOVA non √©quilibr√©e

Afin de r√®gler ce probl√®me est de prendre une nouvelle approche pour tester les effets de chaque variable.

**Type I** : Teste les effets en s√©quentiel, en d√©butant avec la premi√®re variable.

**Type II**: Teste les effets de chaque facteur, mais apr√®s avoir tester l'autre facteur.

**Type III**: Teste les effets de chaque facteur, mais apr√®s avoir tester l'autre facteur et l'int√©raction.

.comment[Le type I est celui par d√©fault dans R et qui cr√©e le probl√®me avec des donn√©es non √©quilibr√©]

.alert[Si vous consid√©rez utiliser le Type II ou III avec vos propres donn√©es, vous devriez en lire plus sur le sujet avant de choisir. Vous pouvez commencer avec ce] [**lien**](https://mcfromnz.wordpress.com/2011/03/02/anova-type-iiiiii-ss-explained/)

---

# ANOVA non √©quilibr√©e

Maintenant essayez une `Anova()` de type III

.pull-left[
.small[
```{r}
car::Anova(unb.anov1, type = "III")
```
]]
.pull-right[
.small[
```{r}
car::Anova(unb.anov2, type = "III")
```
]]

.comment[Que remarquez-vous en utilisant `Anova()` ?]

---
class: inverse, center, middle

# R√©gression polynomiale

---
# R√©gression polynomiale

Comme nous l'avons remarqu√© dans la section sur la **r√©gression lin√©aire multiple**, certaines variables semblent avoir des relations non-lin√©aires avec la variable `MaxAbund`

Pour tester des relations non-lin√©aires, des r√©gressions polynomiales de diff√©rents degr√©s sont compar√©es

- Un mod√®le polyn√¥mial ressemble √† ceci :

.center[$$\underbrace{2x^4}+\underbrace{3x}-\underbrace{2}$$]

.comment[Ce polyn√¥me a trois termes]

---
# R√©gression polynomiale

Pour un polyn√¥me avec une variable (comme $x$ ), le *degr√©* est l'exposant le plus √©lev√© de cette variable

<br>
.center[*Nous avons ici un polyn√¥me de degr√© 4*]
$$2x^\overbrace{4} + 3x - 2$$

---
# R√©gression polynomiale

Lorsque vous connaissez le degr√©, vous pouvez lui donner un nom :

```{r echo=FALSE, warning=FALSE}

poly.reg=data.frame(degre = 0:5,
                    Nom = c("Constante","Lin√©aire","Quadratique",
                             "Cubique","Quartique","Quintique"),
                    Example = c("\\(3\\)",
                                "\\(x+9\\)",
                                "\\(x^2-x+4\\)",
                                "\\(x^3-x^2+5\\)",
                                "\\(6x^4-x^3+x-2\\)",
                                "\\(x^5-3x^3+x^2+8\\)"))
knitr::kable(poly.reg, format = "html", escape=FALSE)
```

---
# R√©gression polynomiale

En utilisant le jeu de donn√©es `Dickcissel`, testez la relation non-lin√©aire entre l'abondance et la temp√©rature en comparant trois mod√®les polyn√¥miaux group√©s (de degr√©s 0, 1, and 3) :

```{r,echo=-c(4:6)}
lm.linear <- lm(abund ~ clDD, data = Dickcissel)
lm.quad   <- lm(abund ~ clDD + I(clDD^2), data = Dickcissel)
lm.cubic  <- lm(abund ~ clDD + I(clDD^2) + I(clDD^3), data = Dickcissel)
summ_lm.linear <- capture.output(summary(lm.linear))[c(9:12, 17, 18)]
summ_lm.quad <- capture.output(summary(lm.quad))[c(9:13, 18, 19)]
summ_lm.cubic <- capture.output(summary(lm.cubic))[c(9:14, 17, 18)]
```

---
# R√©gression polynomiale

- Comparez les mod√®les polynomiaux et d√©terminez quel mod√®le nich√© nous devrions s√©lectionner
- Ex√©cutez un r√©sum√© de ce mod√®le, reportez l'√©quation de la r√©gression, les valeurs de p, et le R carr√© ajust√©

---
# R√©gression polynomiale

Comparez les mod√®les polyn√¥miaux; .comment[quel mod√®le nich√© nous devrions s√©lectionner ?]

Ex√©cutez un r√©sum√© de ce mod√®le

.tiny[
```{r}
print(summ_lm.linear)
```
```{r}
print(summ_lm.quad)
```
```{r}
print(summ_lm.cubic)
```
]

---
class: inverse, center, middle

# Partitionnement de la variation

---
# Partitionnement de la variation

Certaines variables explicatives de la **r√©gression lin√©aire multiple** √©taient fortement corr√©l√©es (c.-√†-d.
multicolin√©arit√©)

La colin√©arit√© entre variables explicatives peut √™tre d√©tect√©e √† l'aide de crit√®res d'inflation de la variance (fonction `vif()` du packet `car`)
  - Les valeurs sup√©rieures √† 5 sont consid√©r√©es colin√©aires

```{r warning=FALSE,message=FALSE}
mod <- lm(clDD ~ clFD + clTmi + clTma + clP + grass, data = Dickcissel)
car::vif(mod)
```

---
# Partitionnement de la variation
.small[
Utilisez `varpart()` afin de partitionner la variation de la variable `abund` avec toutes les variables de la couverture du paysage group√©es ensemble et toutes les variables du climat group√©es ensemble (laissez NDVI √† part)]

.pull-left2[
.tiny[
```{r warning=FALSE,message=FALSE}
library(vegan)
part.lm = varpart(Dickcissel$abund, Dickcissel[ ,c("clDD","clFD","clTmi","clTma","clP")],
                  Dickcissel[ ,c("broadleaf","conif","grass","crop", "urban","wetland")])
part.lm
```
]]
.pull-right2[
<br><br>
.small[.comment[**Note** : les variables colin√©aires n'ont pas besoin d'√™tre enlev√©es avant l'analyse]]
]

---
# Partitionnement de la variation

.pull-left[
.small[
```{r,fig.height=3.2,echo=-1}
par(mar=rep(0.5,4))
showvarparts(2)
```

```{r,eval=FALSE}
?showvarparts
# With two explanatory tables, the fractions
# explained uniquely by each of the two tables
# are ‚Äò[a]‚Äô and ‚Äò[c]‚Äô, and their joint effect
# is ‚Äò[b]‚Äô following Borcard et al. (1992).
```
]]

.pull-right[
.small[
```{r,fig.height=4,echo=-1}
par(mar=rep(0.5,4))
plot(part.lm,
     digits = 2,
     bg = rgb(48,225,210,80,
              maxColorValue=225),
     col = "turquoise4")
```
]]

.small[.comment[La proportion de la variation de la variable abund expliqu√©e par le climat seulement est 28.5% (obtenu par X1|X2), par la couverture du paysage seulement est ~0% (X2|X1), et par les deux combin√©s est 2.4%]]

---
# Partitionnement de la variation

Tester si chaque fraction est significative

- Climat seul
```{r,eval=FALSE}
out.1 = rda(Dickcissel$abund,
            Dickcissel[ ,c("clDD", "clFD","clTmi","clTma","clP")],
            Dickcissel[ ,c("broadleaf","conif","grass","crop", "urban","wetland")])
```

- Couverture du paysage seul
```{r,eval=FALSE}
out.2 = rda(Dickcissel$abund,
            Dickcissel[ ,c("broadleaf","conif","grass","crop", "urban", "wetland")],
            Dickcissel[ ,c("clDD","clFD","clTmi", "clTma","clP")])

```

```{r,include=FALSE}
out.1 = rda(Dickcissel$abund,
            Dickcissel[ ,c("clDD", "clFD","clTmi","clTma","clP")],
            Dickcissel[ ,c("broadleaf","conif","grass","crop", "urban","wetland")])
out.2 = rda(Dickcissel$abund,
            Dickcissel[ ,c("broadleaf","conif","grass","crop", "urban", "wetland")],
            Dickcissel[ ,c("clDD","clFD","clTmi", "clTma","clP")])
```

---
# Partitionnement de la variation

.pull-left[
.small[
```{r}
# Climat seul
anova(out.1, step = 1000, perm.max = 1000)
```
]]

.pull-right[
.small[
```{r}
# Couverture du paysage seul
anova(out.2, step = 1000, perm.max = 1000)
```
]]

.comment[Conclusion: la fraction expliqu√©e par la couverture du paysage n'est pas significative une fois que nous avons pris en compte l'effet du climat]

---
class: inverse, center, bottom

# Merci d'avoir particip√© !

![:scale 50%](images/qcbs_logo.png)
